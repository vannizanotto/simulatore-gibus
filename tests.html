<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Suite - Simulatore Gibus FEM</title>
    <style>
        body { 
            font-family: 'Segoe UI', system-ui, sans-serif; 
            max-width: 1200px; 
            margin: 20px auto; 
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #333; border-bottom: 3px solid #FFD100; padding-bottom: 10px; }
        .test-group { 
            background: white; 
            margin: 20px 0; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-case { 
            margin: 10px 0; 
            padding: 10px; 
            border-left: 4px solid #ccc;
            background: #f9f9f9;
        }
        .test-case.pass { border-left-color: #4CAF50; background: #f1f8f4; }
        .test-case.fail { border-left-color: #f44336; background: #fff5f5; }
        .test-case.running { border-left-color: #2196F3; background: #f0f7ff; }
        .test-title { font-weight: bold; margin-bottom: 5px; }
        .test-details { font-size: 0.9em; color: #666; font-family: monospace; }
        .test-error { color: #f44336; margin-top: 5px; font-size: 0.85em; }
        .summary {
            background: #333;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .summary-item { text-align: center; }
        .summary-label { font-size: 0.8em; opacity: 0.8; text-transform: uppercase; }
        .summary-value { font-size: 2em; font-weight: bold; margin: 5px 0; }
        .pass-count { color: #4CAF50; }
        .fail-count { color: #f44336; }
        .total-count { color: #FFD100; }
        button {
            background: #FFD100;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover { background: #ffc400; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #svgHiddenContainer { position: absolute; left: -9999px; }
    </style>
</head>
<body>
    <h1>üß™ Test Suite - Simulatore Gibus FEM v4.1</h1>
    
    <div class="summary" id="summary">
        <div class="summary-item">
            <div class="summary-label">Totale Test</div>
            <div class="summary-value total-count" id="total-count">0</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">‚úÖ Passati</div>
            <div class="summary-value pass-count" id="pass-count">0</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">‚ùå Falliti</div>
            <div class="summary-value fail-count" id="fail-count">0</div>
        </div>
        <div class="summary-item">
            <div class="summary-label">‚è±Ô∏è Tempo</div>
            <div class="summary-value" id="time-count">0ms</div>
        </div>
    </div>

    <div>
        <button onclick="runAllTests()">‚ñ∂Ô∏è Esegui Tutti i Test</button>
        <button onclick="runSVGTests()">üìÑ Test SVG</button>
        <button onclick="runFEMTests()">üîß Test FEM</button>
        <button onclick="clearResults()">üóëÔ∏è Pulisci</button>
    </div>

    <div id="test-results"></div>

    <!-- Hidden container for SVG rendering -->
    <div id="svgHiddenContainer"></div>

    <!-- Load FEM Engine -->
    <script src="fem_engine_v4.js"></script>

    <script>
        // ===================================================================
        // TEST FRAMEWORK
        // ===================================================================
        
        const testResults = {
            total: 0,
            passed: 0,
            failed: 0,
            startTime: 0,
            tests: []
        };

        function clearResults() {
            testResults.total = 0;
            testResults.passed = 0;
            testResults.failed = 0;
            testResults.tests = [];
            document.getElementById('test-results').innerHTML = '';
            updateSummary();
        }

        function updateSummary() {
            document.getElementById('total-count').textContent = testResults.total;
            document.getElementById('pass-count').textContent = testResults.passed;
            document.getElementById('fail-count').textContent = testResults.failed;
            if (testResults.startTime > 0) {
                const elapsed = Date.now() - testResults.startTime;
                document.getElementById('time-count').textContent = elapsed + 'ms';
            }
        }

        function createTestGroup(title) {
            const group = document.createElement('div');
            group.className = 'test-group';
            group.innerHTML = `<h2>${title}</h2>`;
            document.getElementById('test-results').appendChild(group);
            return group;
        }

        function runTest(testCase, groupElement) {
            testResults.total++;
            
            const testDiv = document.createElement('div');
            testDiv.className = 'test-case running';
            testDiv.innerHTML = `
                <div class="test-title">‚è≥ ${testCase.name}</div>
                <div class="test-details">Esecuzione...</div>
            `;
            groupElement.appendChild(testDiv);

            try {
                const startTime = performance.now();
                const result = testCase.fn();
                const elapsed = performance.now() - startTime;

                if (result.pass) {
                    testResults.passed++;
                    testDiv.className = 'test-case pass';
                    testDiv.innerHTML = `
                        <div class="test-title">‚úÖ ${testCase.name}</div>
                        <div class="test-details">${result.message || 'Test passato'} (${elapsed.toFixed(2)}ms)</div>
                    `;
                } else {
                    testResults.failed++;
                    testDiv.className = 'test-case fail';
                    testDiv.innerHTML = `
                        <div class="test-title">‚ùå ${testCase.name}</div>
                        <div class="test-details">${result.message || 'Test fallito'}</div>
                        <div class="test-error">${result.error || ''}</div>
                    `;
                }

                testResults.tests.push({ ...testCase, ...result, elapsed });
                
            } catch (error) {
                testResults.failed++;
                testDiv.className = 'test-case fail';
                testDiv.innerHTML = `
                    <div class="test-title">‚ùå ${testCase.name}</div>
                    <div class="test-details">Errore durante esecuzione</div>
                    <div class="test-error">${error.message}\n${error.stack}</div>
                `;
                
                testResults.tests.push({ ...testCase, pass: false, error: error.message });
            }

            updateSummary();
        }

        // ===================================================================
        // SVG LOADING TESTS
        // ===================================================================

        const svgTests = [
            {
                name: 'SVG Parser - Rettangolo Semplice',
                fn: () => {
                    const svgText = `<svg><rect x="0" y="0" width="100" height="50" /></svg>`;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, "image/svg+xml");
                    const hasError = doc.querySelector('parsererror');
                    
                    return {
                        pass: !hasError,
                        message: hasError ? 'Parsing fallito' : 'SVG parsato correttamente'
                    };
                }
            },
            {
                name: 'SVG Parser - Path Complesso',
                fn: () => {
                    const svgText = `<svg><path d="M 10,10 L 50,10 L 50,50 L 10,50 Z" /></svg>`;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, "image/svg+xml");
                    const paths = doc.querySelectorAll('path');
                    
                    return {
                        pass: paths.length === 1,
                        message: `Trovati ${paths.length} path`
                    };
                }
            },
            {
                name: 'SVG Contour Extraction - Rettangolo',
                fn: () => {
                    const svgText = `<svg><rect x="10" y="10" width="80" height="40" /></svg>`;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, "image/svg+xml");
                    
                    const container = document.getElementById('svgHiddenContainer');
                    container.innerHTML = '';
                    const svgEl = doc.documentElement;
                    container.appendChild(document.importNode(svgEl, true));
                    
                    const rect = container.querySelector('rect');
                    const points = [];
                    
                    // Simulate contour extraction
                    const x = parseFloat(rect.getAttribute('x')) || 0;
                    const y = parseFloat(rect.getAttribute('y')) || 0;
                    const w = parseFloat(rect.getAttribute('width'));
                    const h = parseFloat(rect.getAttribute('height'));
                    
                    // Should form 4 corners
                    const expectedPoints = [
                        {x, y},
                        {x: x + w, y},
                        {x: x + w, y: y + h},
                        {x, y: y + h}
                    ];
                    
                    return {
                        pass: w === 80 && h === 40,
                        message: `Geometria estratta: ${w}x${h}`
                    };
                }
            },
            {
                name: 'SVG Transformation - CTM Application',
                fn: () => {
                    const svgText = `<svg><g transform="scale(2)"><rect x="10" y="10" width="20" height="20" /></g></svg>`;
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(svgText, "image/svg+xml");
                    
                    const container = document.getElementById('svgHiddenContainer');
                    container.innerHTML = '';
                    container.appendChild(document.importNode(doc.documentElement, true));
                    
                    const rect = container.querySelector('rect');
                    let hasTransform = false;
                    
                    try {
                        const ctm = rect.getCTM();
                        hasTransform = ctm && (ctm.a !== 1 || ctm.d !== 1);
                    } catch (e) {
                        hasTransform = false;
                    }
                    
                    return {
                        pass: hasTransform,
                        message: hasTransform ? 'Trasformazione applicata via CTM' : 'CTM non disponibile (normale in headless)'
                    };
                }
            },
            {
                name: 'SVG Area Calculation - Profilo Rettangolare',
                fn: () => {
                    // Simula il calcolo dell'area di un profilo rettangolare cavo
                    // Esterno: 60x30 mm, Interno: 54x24 mm (spessore 3mm)
                    const outerArea = 60 * 30; // 1800 mm¬≤
                    const innerArea = 54 * 24; // 1296 mm¬≤
                    const netArea = outerArea - innerArea; // 504 mm¬≤
                    
                    const expectedArea = 504;
                    const tolerance = 1; // 1 mm¬≤
                    
                    return {
                        pass: Math.abs(netArea - expectedArea) < tolerance,
                        message: `Area calcolata: ${netArea} mm¬≤ (attesa: ${expectedArea} mm¬≤)`
                    };
                }
            }
        ];

        // ===================================================================
        // FEM ENGINE TESTS
        // ===================================================================

        const femTests = [
            {
                name: 'FEM - Verifica Caricamento MATERIALS_V4',
                fn: () => {
                    const hasMaterials = typeof window.MATERIALS_V4 !== 'undefined';
                    const has6061 = hasMaterials && window.MATERIALS_V4['6061-T6'];
                    
                    return {
                        pass: has6061 !== undefined,
                        message: hasMaterials ? `Database materiali caricato (${Object.keys(window.MATERIALS_V4).length} materiali)` : 'Database non trovato'
                    };
                }
            },
            {
                name: 'FEM - Hole Stress Analysis (Peterson Kt)',
                fn: () => {
                    if (typeof window.HoleStressAnalysis === 'undefined') {
                        return { pass: false, message: 'HoleStressAnalysis non disponibile' };
                    }
                    
                    const analysis = new window.HoleStressAnalysis({
                        d: 4,      // 4mm hole
                        p: 50,     // 50mm spacing
                        t: 3,      // 3mm thickness
                        W: 33,     // 33mm width
                        n: 1,      // single hole
                        material: '6061-T6'
                    });
                    
                    const Kt = analysis.calculateKt_Peterson();
                    
                    // For d/W = 4/33 ‚âà 0.121, expect Kt ‚âà 2.6
                    const expectedKt = 2.6;
                    const tolerance = 0.3;
                    
                    return {
                        pass: Kt >= (expectedKt - tolerance) && Kt <= (expectedKt + tolerance),
                        message: `Kt calcolato: ${Kt.toFixed(3)} (range atteso: ${(expectedKt - tolerance).toFixed(2)}-${(expectedKt + tolerance).toFixed(2)})`
                    };
                }
            },
            {
                name: 'FEM - Net Section Analysis (EC9)',
                fn: () => {
                    if (typeof window.NetSectionAnalysis === 'undefined') {
                        return { pass: false, message: 'NetSectionAnalysis non disponibile' };
                    }
                    
                    // Mock section
                    const grossSection = {
                        A: 0.0005,  // 500 mm¬≤ = 0.0005 m¬≤
                        I: 2e-8,    // m‚Å¥
                        H: 0.06     // 60mm
                    };
                    
                    const holes = {
                        n: 3,
                        d: 4,       // 4mm
                        y: 28,      // 28mm from neutral axis
                        t: 3        // 3mm thickness
                    };
                    
                    const netAnalysis = new window.NetSectionAnalysis(grossSection, holes);
                    const netArea = netAnalysis.calculateNetArea();
                    
                    // Expected: 500 - (3 holes √ó 4mm √ó 3mm) = 500 - 36 = 464 mm¬≤ = 0.000464 m¬≤
                    const expectedNetArea = 0.000464;
                    const tolerance = 0.00001;
                    
                    return {
                        pass: Math.abs(netArea - expectedNetArea) < tolerance,
                        message: `Area netta: ${(netArea * 1e6).toFixed(1)} mm¬≤ (attesa: ${(expectedNetArea * 1e6).toFixed(1)} mm¬≤)`
                    };
                }
            },
            {
                name: 'FEM - Bearing Analysis (EC9)',
                fn: () => {
                    if (typeof window.BearingAnalysis === 'undefined' || typeof window.MATERIALS_V4 === 'undefined') {
                        return { pass: false, message: 'BearingAnalysis o MATERIALS_V4 non disponibili' };
                    }
                    
                    const material = window.MATERIALS_V4['6061-T6'];
                    const bearing = new window.BearingAnalysis(
                        { diameter: 4, f_ub: 400 },      // M4 bolt
                        { thickness: 3, e1: 15, p1: 50 }, // Plate params
                        material
                    );
                    
                    const F_b_Rd = bearing.calculateBearingResistance();
                    
                    // Bearing resistance should be > 0 and reasonable (typically 1000-5000 N for M4 in aluminum)
                    const isReasonable = F_b_Rd > 500 && F_b_Rd < 10000;
                    
                    return {
                        pass: isReasonable,
                        message: `Resistenza bearing: ${F_b_Rd.toFixed(0)} N (range ragionevole: 500-10000 N)`
                    };
                }
            },
            {
                name: 'FEM - Fatigue Notch Analysis (Peterson Kf)',
                fn: () => {
                    if (typeof window.FatigueNotchAnalysis === 'undefined') {
                        return { pass: false, message: 'FatigueNotchAnalysis non disponibile' };
                    }
                    
                    const Kt = 2.5;
                    const notchRadius = 0.5; // mm
                    const fatigue = new window.FatigueNotchAnalysis('6061-T6', Kt, notchRadius);
                    
                    const q = fatigue.calculateNotchSensitivity();
                    const Kf = fatigue.calculateKf();
                    
                    // q should be 0 < q ‚â§ 1
                    // Kf should be 1 < Kf ‚â§ Kt
                    const validQ = q > 0 && q <= 1;
                    const validKf = Kf >= 1 && Kf <= Kt;
                    
                    return {
                        pass: validQ && validKf,
                        message: `q=${q.toFixed(3)}, Kf=${Kf.toFixed(3)} (Kt=${Kt})`
                    };
                }
            },
            {
                name: 'FEM - BeamSectionWithHoles Integration',
                fn: () => {
                    if (typeof window.BeamSectionWithHoles === 'undefined') {
                        return { pass: false, message: 'BeamSectionWithHoles non disponibile' };
                    }
                    
                    const section = new window.BeamSectionWithHoles({
                        type: 'hollow_rect',
                        width: 0.033,    // 33mm
                        height: 0.062,   // 62mm
                        t_v: 0.003,      // 3mm
                        t_h: 0.003,      // 3mm
                        numHoles: 3,
                        holeDiameter_mm: 4.2,
                        holeSpacing_mm: 50,
                        materialKey: '6061-T6',
                        notchRadius_mm: 0.5
                    });
                    
                    // Check that basic properties are calculated
                    const hasArea = section.A > 0;
                    const hasInertia = section.I > 0;
                    const hasKt = section.Kt >= 1;
                    
                    return {
                        pass: hasArea && hasInertia && hasKt,
                        message: `A=${(section.A * 1e6).toFixed(1)} mm¬≤, I=${(section.I * 1e8).toFixed(2)} cm‚Å¥, Kt=${section.Kt.toFixed(2)}`
                    };
                }
            },
            {
                name: 'FEM - Advanced Hole Analysis (Complete)',
                fn: () => {
                    if (typeof window.BeamSectionWithHoles === 'undefined') {
                        return { pass: false, message: 'BeamSectionWithHoles non disponibile' };
                    }
                    
                    const section = new window.BeamSectionWithHoles({
                        type: 'hollow_rect',
                        width: 0.033,
                        height: 0.062,
                        t_v: 0.003,
                        t_h: 0.003,
                        numHoles: 3,
                        holeDiameter_mm: 4.2,
                        holeSpacing_mm: 50,
                        materialKey: '6061-T6'
                    });
                    
                    section.performAdvancedAnalysis();
                    const results = section.getAdvancedResults(150, 800);
                    
                    // Verify all analysis results are present
                    const hasKt = results.Kt_effective > 0;
                    const hasKf = results.Kf > 0;
                    const hasSigma = results.sigma_max_local >= 0;
                    const hasFatigue = results.fatigue_safety_factor > 0;
                    
                    const allPresent = hasKt && hasKf && hasSigma && hasFatigue;
                    
                    return {
                        pass: allPresent,
                        message: `Kt=${results.Kt_effective.toFixed(2)}, Kf=${results.Kf.toFixed(2)}, œÉ_max=${results.sigma_max_local.toFixed(1)} MPa, SF=${results.fatigue_safety_factor.toFixed(2)}`
                    };
                }
            },
            {
                name: 'FEM - Local Mesh Refinement',
                fn: () => {
                    if (typeof window.LocalMeshRefinement === 'undefined') {
                        return { pass: false, message: 'LocalMeshRefinement non disponibile' };
                    }
                    
                    const geometry = {
                        centerX: 0,
                        centerY: 0,
                        radius: 2,
                        domainSize: 16
                    };
                    
                    const material = window.MATERIALS_V4 ? window.MATERIALS_V4['6061-T6'] : {};
                    const localMesh = new window.LocalMeshRefinement(geometry, material, {
                        refinementLevels: 2,
                        angularDivisions: 8
                    });
                    
                    const meshData = localMesh.generateRefinedMesh();
                    
                    // Should have nodes and elements
                    const hasNodes = meshData.numNodes > 0;
                    const hasElements = meshData.numElements > 0;
                    
                    return {
                        pass: hasNodes && hasElements,
                        message: `Mesh: ${meshData.numNodes} nodi, ${meshData.numElements} elementi`
                    };
                }
            },
            {
                name: 'FEM - Kirsch Solution Validation',
                fn: () => {
                    if (typeof window.LocalMeshRefinement === 'undefined' || typeof window.MATERIALS_V4 === 'undefined') {
                        return { pass: false, message: 'LocalMeshRefinement non disponibile' };
                    }
                    
                    const geometry = { centerX: 0, centerY: 0, radius: 2, domainSize: 16 };
                    const material = window.MATERIALS_V4['6061-T6'];
                    const localMesh = new window.LocalMeshRefinement(geometry, material);
                    
                    localMesh.generateRefinedMesh();
                    const sigma_remote = 100; // MPa
                    const stresses = localMesh.solveLocalElasticProblem(sigma_remote);
                    const ktResult = localMesh.extractStressConcentrationFactor(stresses, sigma_remote);
                    
                    // Kt should be close to 3.0 (Kirsch theory)
                    const error = ktResult.error_percent;
                    const isAccurate = error < 5; // Less than 5% error
                    
                    return {
                        pass: isAccurate,
                        message: `Kt numerico: ${ktResult.Kt_numeric.toFixed(3)}, teoria: ${ktResult.Kt_theory}, errore: ${error.toFixed(2)}%`
                    };
                }
            }
        ];

        // ===================================================================
        // TEST RUNNERS
        // ===================================================================

        function runSVGTests() {
            clearResults();
            testResults.startTime = Date.now();
            const group = createTestGroup('üìÑ Test SVG Loading & Processing');
            svgTests.forEach(test => runTest(test, group));
        }

        function runFEMTests() {
            clearResults();
            testResults.startTime = Date.now();
            const group = createTestGroup('üîß Test FEM Engine v4.1');
            femTests.forEach(test => runTest(test, group));
        }

        function runAllTests() {
            clearResults();
            testResults.startTime = Date.now();
            
            const svgGroup = createTestGroup('üìÑ Test SVG Loading & Processing');
            svgTests.forEach(test => runTest(test, svgGroup));
            
            const femGroup = createTestGroup('üîß Test FEM Engine v4.1');
            femTests.forEach(test => runTest(test, femGroup));
        }

        // Auto-run on load (optional)
        // window.addEventListener('DOMContentLoaded', runAllTests);
    </script>
</body>
</html>
